{"meta":{"title":"Hugo's blog","subtitle":"记录一些问题分享","description":"","author":"Hugo","url":"https://hugobbtt.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-08-20T06:56:45.000Z","updated":"2020-08-20T06:59:21.124Z","comments":true,"path":"categories/index.html","permalink":"https://hugobbtt.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-08-20T06:58:22.000Z","updated":"2020-08-20T17:50:13.211Z","comments":true,"path":"about/index.html","permalink":"https://hugobbtt.github.io/about/index.html","excerpt":"","text":"民工小黄 坐标深圳 编程时间不长，每天进步一点点"}],"posts":[{"title":"有关TCP的常见问题","slug":"有关TCP的常见问题","date":"2020-08-20T07:47:06.000Z","updated":"2020-08-20T17:46:24.531Z","comments":true,"path":"2020/08/20/有关TCP的常见问题/","link":"","permalink":"https://hugobbtt.github.io/2020/08/20/%E6%9C%89%E5%85%B3TCP%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"三次握手三次挥手的目的 建立可靠的通信信道，让双方都确定自己与对方的发送和接收是正常的。 防止失效的连接请求到达服务器，让服务器错误打开连接。 三次挥手的过程 第一次握手：服务端确认客户端的发送功能，自己的接收功能。SYN=1，初始序号SEQ=x 第二次握手：客户端确认自己的发送、接收功能，服务端的发送、接收功能。SYN=1，确认号ACK=x+1，同时也选择一个初始序号SEQ=y 第三次握手：服务端确认自己的发送功能，客户端的接收功能。确认号ACK=y+1，序号为SEQ=x+1 为什么要传回SYN：接收端传回发送端所发送的SYN是为了告诉发送端，我接受到的信息确实是你所发送的信号，而不是别人的。 四次挥手 客户端-发送连接释放报文FIN，用来关闭客户端到服务器的数据传送，FIN=1，初始序号SEQ=u 服务器-收到这个 FIN，它发回一个确认ACK，此时TCP处于半关闭状态（CLOSE-WAIT），B能向A发数据但A不能向B发数据。确认号ACK=u+1，同时也初始一个序号SEQ=v 当服务器不再需要发送数据时，发送释放连接报文FIN。FIN=1，ACK=u+1，序号SEQ=w 客户端-发回 ACK 报文确认，进入TIME-WAIT状态，等待2倍的MSL（最大报文存活时间 Maximum Segment Lifetime）后释放连接。确认号ACK=w+1，序号u+1 服务器收到ACK后释放连接。 为什么要有TIME-WAIT状态，而不是直接进入CLOSED状态： 确保最后一个确认报文ACK能够到达服务端，如果服务端没有收到客户端的ACK报文，最需要重新发送连接释放请求报文FIN，即重新来过。客户端等待的2倍MSL时间就是为了处理这种情况的发生。 等待时间是为了让本次连接持续时间内产生的所有报文都从网络中消失，使得下一次新的连接不会出现旧的连接请求报文SYN，从而错误打开连接。 TCP流量控制(Flow Control) 流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能够接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口的大小，从而影响发送方的发送速率。如果将窗口字段设置成0，则发送方不能发送数据。接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP拥塞控制(Congestion Control)慢启动（slow start）和拥塞避免（Congestion Avoidance）： 发动的最初执行慢开始，令拥塞窗口cwnd=1 (congestion window)**，发送方只能发送1个报文段；当收到ACK确认后，将cwnd加倍，因此之后发送方能够发送的报文段数量为2,4,8,…..由于指数增长的非常快，网络拥塞的可能性也就很高。设置一个慢开始门限ssthresh，当swnd&gt;=ssthresh时，进入拥塞避免，每个轮次只将cwnd加1。 如果出现了连接超时，则令ssthresh=cwnd/2，然后重新执行慢开始 cwnd=1。** 快重传和快恢复： 接收方每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。发送方如果收到三个重复确认，那么就可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。通知执行快恢复，令ssthresh=cwnd/2，cwnd=ssthresh，此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是cwnd的设定值，而不是cwnd的增长速率（刚好相反）。慢开始cwnd设定为1，增长率为指数增长，而快恢复cwnd设定为ssthresh，增长率为线性增长。 拥塞控制是一种自适应的机制，用来推断当前带宽的大小，以及网路的拥挤程度。 应用层也可以实现这种自适应机制，比如说看视频的时候，是从模糊到越来越清晰，若网络有故障就会减低清晰度。这种应用于视频流的机制被称为“自适应比特流”。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hugobbtt.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"第一篇博客","slug":"My-New-Post","date":"2020-08-14T16:02:35.000Z","updated":"2020-08-15T05:21:25.707Z","comments":true,"path":"2020/08/15/My-New-Post/","link":"","permalink":"https://hugobbtt.github.io/2020/08/15/My-New-Post/","excerpt":"","text":"标题有的人可能18岁就搭了自己的博客，而有的人在26岁的时候才搭上，不管怎样，只要开始就是好的吧。 打算就是在这个博客了记录一下遇到的技术问题，分享一些总结到的知识。主要是有利于自己巩固知识，因为只有输出了才是自己的，如果还能有幸帮助到别人也是很好的。 靡不有初鲜克有终。","categories":[],"tags":[]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://hugobbtt.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]}